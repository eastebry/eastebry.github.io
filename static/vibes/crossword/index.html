<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#1f2937" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="/vibes/crossword/manifest.webmanifest" />
  <link rel="icon" href="/vibes/crossword/icon.svg" type="image/svg+xml" />
  <title>Crossword Vibes</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --panel: #1f2937;
      --ink: #e5e7eb;
      --accent: #60a5fa;
      --warn: #fb7185;
      --ok: #22c55e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100svh;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at top, #1e293b, var(--bg));
      color: var(--ink);
      display: grid;
      place-items: center;
      padding: 10px;
    }
    .app {
      width: min(100%, 980px);
      background: color-mix(in srgb, var(--panel) 88%, black);
      border: 1px solid #334155;
      border-radius: 16px;
      padding: 12px;
      display: grid;
      gap: 12px;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .pill {
      border: 1px solid #475569;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.9rem;
      background: #0f172a;
    }
    button {
      appearance: none;
      border: 1px solid #64748b;
      background: #0f172a;
      color: var(--ink);
      border-radius: 10px;
      padding: 10px 12px;
      min-height: 42px;
      font-weight: 700;
      cursor: pointer;
    }
    button.primary {
      border-color: #3b82f6;
      background: color-mix(in srgb, #1d4ed8 45%, #0f172a);
    }
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .status {
      font-size: 0.95rem;
      color: #cbd5e1;
      min-height: 1.3rem;
    }
    .status.error { color: var(--warn); }
    .status.ok { color: var(--ok); }
    #game {
      width: 100%;
      min-height: 560px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #334155;
      background: #020617;
    }
    details {
      border: 1px solid #334155;
      border-radius: 10px;
      padding: 8px 10px;
      background: #0b1220;
    }
    summary { cursor: pointer; }
    ul { margin: 6px 0 0 18px; padding: 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body>
  <main class="app">
    <div class="toolbar">
      <div class="pill" id="dateLabel"></div>
      <div class="pill" id="scoreLabel">Score: 0</div>
      <div class="pill" id="wordsLabel">Words: —</div>
      <button id="installBtn" disabled>Install</button>
      <button id="clearBtn">Clear Board</button>
      <button id="submitBtn" class="primary">Submit Daily Score</button>
    </div>
    <div class="status" id="status"></div>
    <div id="game" role="application" aria-label="Crossword board"></div>
    <details>
      <summary>Scoring rules</summary>
      <ul>
        <li>Each valid word scores points equal to its length.</li>
        <li>Blue <strong>2×</strong> squares double any word that uses them.</li>
        <li>Red <strong>-2</strong> squares subtract two points when a tile is on them.</li>
        <li>Each unused rack tile subtracts one point.</li>
      </ul>
    </details>
  </main>

  <script>
    const WORDS = [
      'ARE','ART','ATE','EAR','EAT','LATE','LATER','RATE','RAT','TAR','TEAR','REAL','RALE',
      'READ','DEAR','DARE','LEAD','DEAL','LAD','ALE','ELAN','LEAN','LANE','LEARN','NEAR',
      'STONE','TONES','NOTE','NOTES','ONES','ONE','TONE','SORE','ROSE','SENT','TEN','NET',
      'LEAST','STEAL','STALE','TALES','SEAL','SALE','TEAL','SLATE','LAST','EAST','EATS',
      'TRAIN','RAIN','RANT','TARN','ANTI','TIN','NIT','AIR','ARTS','STAR','STARE','TEARS'
    ];
    const WORD_SET = new Set(WORDS);

    const PUZZLES = [
      {
        rack: 'LATERNSO',
        blocked: ['0,0','0,6','6,0','6,6','3,3'],
        doubleWord: ['1,1','5,5','1,5'],
        minusTwo: ['2,4','4,2']
      },
      {
        rack: 'DEALRANT',
        blocked: ['0,3','1,3','5,3','6,3','3,0','3,6'],
        doubleWord: ['2,2','4,4'],
        minusTwo: ['1,5','5,1']
      },
      {
        rack: 'STONEAIR',
        blocked: ['0,1','0,5','6,1','6,5','3,3'],
        doubleWord: ['2,2','2,4','4,2','4,4'],
        minusTwo: ['1,3','5,3']
      }
    ];

    const SIZE = 7;
    const CELL = 62;
    const GAP = 6;

    function todayKey() {
      return new Date().toISOString().slice(0, 10);
    }

    function pickDailyPuzzle() {
      const key = todayKey();
      let hash = 0;
      for (const ch of key) hash = (hash * 31 + ch.charCodeAt(0)) >>> 0;
      const index = hash % PUZZLES.length;
      return JSON.parse(JSON.stringify(PUZZLES[index]));
    }

    function parseCells(list) {
      return new Set(list.map((v) => v));
    }

    function scoreBoard(board, rack, puzzle) {
      const blocked = parseCells(puzzle.blocked);
      const dbl = parseCells(puzzle.doubleWord);
      const minus = parseCells(puzzle.minusTwo);
      const words = [];
      const invalid = [];
      let points = 0;
      let penalties = 0;

      const get = (r, c) => board[r][c];

      for (let r = 0; r < SIZE; r += 1) {
        let c = 0;
        while (c < SIZE) {
          const key = `${r},${c}`;
          if (blocked.has(key) || !get(r, c) || (c > 0 && get(r, c - 1))) {
            c += 1;
            continue;
          }
          let end = c;
          let word = '';
          let multiplier = 1;
          while (end < SIZE && get(r, end)) {
            word += get(r, end);
            if (dbl.has(`${r},${end}`)) multiplier *= 2;
            end += 1;
          }
          if (word.length > 1) {
            words.push(word);
            if (WORD_SET.has(word)) points += word.length * multiplier;
            else invalid.push(word);
          }
          c = end + 1;
        }
      }

      for (let c = 0; c < SIZE; c += 1) {
        let r = 0;
        while (r < SIZE) {
          const key = `${r},${c}`;
          if (blocked.has(key) || !get(r, c) || (r > 0 && get(r - 1, c))) {
            r += 1;
            continue;
          }
          let end = r;
          let word = '';
          let multiplier = 1;
          while (end < SIZE && get(end, c)) {
            word += get(end, c);
            if (dbl.has(`${end},${c}`)) multiplier *= 2;
            end += 1;
          }
          if (word.length > 1) {
            words.push(word);
            if (WORD_SET.has(word)) points += word.length * multiplier;
            else invalid.push(word);
          }
          r = end + 1;
        }
      }

      for (let r = 0; r < SIZE; r += 1) {
        for (let c = 0; c < SIZE; c += 1) {
          if (board[r][c] && minus.has(`${r},${c}`)) penalties += 2;
        }
      }

      const unused = rack.filter(Boolean).length;
      const total = points - penalties - unused;
      return { total, words, invalid, points, penalties, unused };
    }

    class CrosswordScene extends Phaser.Scene {
      constructor() {
        super('crossword');
      }

      create() {
        this.puzzle = pickDailyPuzzle();
        this.blocked = parseCells(this.puzzle.blocked);
        this.doubleWord = parseCells(this.puzzle.doubleWord);
        this.minusTwo = parseCells(this.puzzle.minusTwo);
        this.board = Array.from({ length: SIZE }, () => Array(SIZE).fill(''));
        this.rack = this.puzzle.rack.split('');
        this.selectedRackIndex = null;
        this.locked = false;

        this.offsetX = 32;
        this.offsetY = 28;
        this.drawBoard();
        this.drawRack();
        this.updateHud();
      }

      drawBoard() {
        this.boardCells = [];
        for (let r = 0; r < SIZE; r += 1) {
          for (let c = 0; c < SIZE; c += 1) {
            const x = this.offsetX + c * (CELL + GAP);
            const y = this.offsetY + r * (CELL + GAP);
            const key = `${r},${c}`;
            let color = 0x1e293b;
            if (this.blocked.has(key)) color = 0x0b1220;
            if (this.doubleWord.has(key)) color = 0x1d4ed8;
            if (this.minusTwo.has(key)) color = 0x9f1239;

            const rect = this.add.rectangle(x, y, CELL, CELL, color).setOrigin(0);
            rect.setStrokeStyle(1, 0x64748b, 0.7);
            rect.setInteractive({ useHandCursor: true });
            rect.on('pointerdown', () => this.tapCell(r, c));
            const label = this.add.text(x + CELL / 2, y + CELL / 2, '', {
              fontSize: '28px',
              fontStyle: '700',
              color: '#f8fafc'
            }).setOrigin(0.5);
            const bonus = this.doubleWord.has(key) ? '2×' : (this.minusTwo.has(key) ? '-2' : '');
            const bonusLabel = this.add.text(x + 5, y + 5, bonus, { fontSize: '14px', color: '#e2e8f0' });
            this.boardCells.push({ rect, label, bonusLabel, r, c });
          }
        }
      }

      drawRack() {
        this.rackSprites = [];
        const startY = this.offsetY + SIZE * (CELL + GAP) + 22;
        this.add.text(this.offsetX, startY - 24, 'Rack', { fontSize: '18px', color: '#cbd5e1' });
        for (let i = 0; i < this.rack.length; i += 1) {
          const x = this.offsetX + i * (CELL + 8);
          const tile = this.add.rectangle(x, startY, CELL, CELL, 0x334155).setOrigin(0);
          tile.setStrokeStyle(2, 0x94a3b8, 0.8);
          tile.setInteractive({ useHandCursor: true });
          tile.on('pointerdown', () => this.selectRack(i));
          const text = this.add.text(x + CELL / 2, startY + CELL / 2, this.rack[i], {
            fontSize: '28px',
            color: '#f8fafc',
            fontStyle: '700'
          }).setOrigin(0.5);
          this.rackSprites.push({ tile, text, i });
        }
      }

      selectRack(index) {
        if (this.locked || !this.rack[index]) return;
        this.selectedRackIndex = index;
        this.refreshRackSelection();
      }

      tapCell(r, c) {
        if (this.locked) return;
        const key = `${r},${c}`;
        if (this.blocked.has(key)) return;
        if (this.board[r][c]) {
          const putBack = this.board[r][c];
          const spot = this.rack.findIndex((v) => !v);
          if (spot >= 0) {
            this.rack[spot] = putBack;
            this.board[r][c] = '';
            this.selectedRackIndex = null;
            this.redraw();
          }
          return;
        }
        if (this.selectedRackIndex === null) return;
        const letter = this.rack[this.selectedRackIndex];
        if (!letter) return;
        this.board[r][c] = letter;
        this.rack[this.selectedRackIndex] = '';
        this.selectedRackIndex = null;
        this.redraw();
      }

      redraw() {
        for (const cell of this.boardCells) {
          cell.label.setText(this.board[cell.r][cell.c] || '');
        }
        for (const tile of this.rackSprites) {
          tile.text.setText(this.rack[tile.i] || '');
          tile.tile.setFillStyle(this.rack[tile.i] ? 0x334155 : 0x1e293b);
        }
        this.refreshRackSelection();
        this.updateHud();
      }

      refreshRackSelection() {
        for (const tile of this.rackSprites) {
          const active = tile.i === this.selectedRackIndex;
          tile.tile.setStrokeStyle(2, active ? 0xfacc15 : 0x94a3b8, 0.9);
        }
      }

      updateHud() {
        const summary = scoreBoard(this.board, this.rack, this.puzzle);
        window.updateStatus(summary, this.locked);
      }

      clearBoard() {
        if (this.locked) return;
        for (let r = 0; r < SIZE; r += 1) {
          for (let c = 0; c < SIZE; c += 1) {
            if (this.board[r][c]) {
              const spot = this.rack.findIndex((v) => !v);
              if (spot >= 0) this.rack[spot] = this.board[r][c];
              this.board[r][c] = '';
            }
          }
        }
        this.selectedRackIndex = null;
        this.redraw();
      }

      submitDaily() {
        const key = todayKey();
        const storageKey = `crossword-submit-${key}`;
        if (localStorage.getItem(storageKey)) return { ok: false, message: 'Already submitted for today.' };
        const summary = scoreBoard(this.board, this.rack, this.puzzle);
        if (!summary.words.length) return { ok: false, message: 'Add at least one word before submitting.' };
        if (summary.invalid.length) return { ok: false, message: `Invalid words: ${summary.invalid.join(', ')}` };
        this.locked = true;
        const payload = {
          score: summary.total,
          words: summary.words,
          board: this.board,
          at: new Date().toISOString()
        };
        localStorage.setItem(storageKey, JSON.stringify(payload));
        this.updateHud();
        return { ok: true, message: `Submitted! Daily score: ${summary.total}` };
      }
    }

    const scene = new CrosswordScene();
    const game = new Phaser.Game({
      type: Phaser.AUTO,
      parent: 'game',
      width: 560,
      height: 640,
      backgroundColor: '#020617',
      scene,
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    });

    const dateLabel = document.getElementById('dateLabel');
    const scoreLabel = document.getElementById('scoreLabel');
    const wordsLabel = document.getElementById('wordsLabel');
    const status = document.getElementById('status');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearBtn');
    const installBtn = document.getElementById('installBtn');

    dateLabel.textContent = `Daily board: ${todayKey()}`;

    window.updateStatus = (summary, locked) => {
      scoreLabel.textContent = `Score: ${summary.total}`;
      wordsLabel.textContent = summary.words.length ? `Words: ${summary.words.join(', ')}` : 'Words: —';
      if (locked) {
        status.textContent = 'Board locked for today. Come back tomorrow for a new rack.';
        status.className = 'status ok';
      } else if (summary.invalid.length) {
        status.textContent = `Invalid words: ${summary.invalid.join(', ')}`;
        status.className = 'status error';
      } else {
        status.textContent = `Base ${summary.points} • Penalties ${summary.penalties + summary.unused}`;
        status.className = 'status';
      }
    };

    submitBtn.addEventListener('click', () => {
      const result = scene.submitDaily();
      status.textContent = result.message;
      status.className = result.ok ? 'status ok' : 'status error';
      if (result.ok) submitBtn.disabled = true;
    });

    clearBtn.addEventListener('click', () => scene.clearBoard());

    const prior = localStorage.getItem(`crossword-submit-${todayKey()}`);
    if (prior) {
      submitBtn.disabled = true;
      status.textContent = 'You already submitted this daily puzzle.';
      status.className = 'status ok';
    }

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/vibes/crossword/sw.js').catch(() => {});
      });
    }

    let deferredPrompt = null;
    window.addEventListener('beforeinstallprompt', (event) => {
      event.preventDefault();
      deferredPrompt = event;
      installBtn.disabled = false;
    });

    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
      installBtn.disabled = true;
    });
  </script>
</body>
</html>
