<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="/vibes/set/manifest.webmanifest" />
  <link rel="icon" href="/vibes/set/icon.svg" type="image/svg+xml" />
  <title>Set</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #111827;
      --panel: #1f2937;
      --card: #f8fafc;
      --ink: #0f172a;
      --ok: #10b981;
      --bad: #ef4444;
      --muted: #94a3b8;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(180deg, #0f172a, var(--bg));
      color: #e2e8f0;
      min-height: 100svh;
    }

    .app {
      width: min(100%, 1000px);
      margin: 0 auto;
      padding: 12px;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr);
      gap: 12px;
      height: 100svh;
      overflow: hidden;
    }

    .toolbar {
      background: rgba(31, 41, 55, 0.9);
      border: 1px solid #334155;
      border-radius: 14px;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .toolbar-top {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .top-status {
      margin-left: auto;
      font-size: 0.95rem;
      color: var(--muted);
      white-space: nowrap;
    }

    .toolbar-extras {
      display: grid;
      gap: 8px;
    }

    .menu-toggle {
      width: 44px;
      min-width: 44px;
      min-height: 44px;
      padding: 6px;
      font-size: 1.25rem;
      line-height: 1;
      display: grid;
      place-items: center;
    }

    .stats {
      display: flex;
      justify-content: flex-start;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .install-overlay {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.8);
      display: grid;
      place-items: center;
      padding: 16px;
      z-index: 20;
    }

    .install-modal {
      width: min(100%, 560px);
      background: rgba(31, 41, 55, 0.98);
      border: 1px solid #475569;
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .install-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .install-header h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .platform-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .platform-tab[aria-pressed='true'] {
      border-color: #60a5fa;
      background: color-mix(in srgb, #2563eb 28%, #0f172a);
    }

    .install-help {
      margin: 0;
      color: #cbd5e1;
      line-height: 1.45;
      white-space: pre-line;
    }

    .install-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .players {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.85rem;
      flex: 1;
    }

    .player-chip {
      border: 1px solid color-mix(in srgb, var(--pcolor) 60%, #334155);
      color: #e2e8f0;
      border-radius: 999px;
      padding: 4px 8px;
      background: color-mix(in srgb, var(--pcolor) 22%, #0f172a);
      opacity: 0.75;
    }

    .player-chip.leading {
      opacity: 1;
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--pcolor) 50%, transparent) inset;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    #installBtn {
      border-color: #60a5fa;
      background: color-mix(in srgb, #2563eb 32%, #0f172a);
      color: #eff6ff;
    }

    @media (max-width: 520px) {
      .controls {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    button {
      appearance: none;
      border: 1px solid #475569;
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 10px;
      padding: 10px;
      font-size: 0.95rem;
      font-weight: 650;
      min-height: 44px;
    }

    button:active { transform: translateY(1px); }

    .grid {
      display: grid;
      --grid-gap: 8px;
      --cols: 3;
      --card-w: 120px;
      --card-h: 200px;
      gap: var(--grid-gap);
      grid-template-columns: repeat(var(--cols), minmax(0, var(--card-w)));
      grid-auto-rows: var(--card-h);
      min-height: 0;
      align-content: center;
      justify-content: center;
      overflow: hidden;
    }

    .board-wrap {
      position: relative;
      min-height: 0;
      display: grid;
      overflow: hidden;
      border-radius: 14px;
    }

    .card {
      border: 3px solid transparent;
      background: var(--card);
      color: var(--ink);
      border-radius: 12px;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      touch-action: manipulation;
      overflow: hidden;
    }

    .card.selected { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.25) inset; }
    .card.good { border-color: var(--ok); }
    .card.bad { border-color: var(--bad); }

    .symbols {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-evenly;
      gap: 4px;
      flex-wrap: nowrap;
      flex-direction: column;
    }

    .symbols svg {
      width: min(100%, var(--symbol-max, 100px));
      height: auto;
      flex: 0 1 auto;
    }

    .grid.portrait-cards .symbols {
      gap: 2px;
    }

    .grid.landscape-cards .symbols {
      transform: rotate(90deg);
      transform-origin: center;
    }

    .msg {
      min-height: 1.2em;
      font-size: 0.95rem;
      color: var(--muted);
    }


    [hidden] { display: none !important; }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #334155;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 5;
    }

    .panel {
      background: rgba(31, 41, 55, 0.95);
      border: 1px solid #475569;
      border-radius: 16px;
      padding: 16px;
      width: min(100%, 500px);
      text-align: center;
    }

    .panel h2 { margin: 0 0 10px; }

    .panel-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .claim-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 4;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .claim-layer.active {
      pointer-events: auto;
      background: rgba(15, 23, 42, 0.25);
      opacity: 1;
      visibility: visible;
    }

    .claim-btn {
      position: absolute;
      border-width: 3px;
      border-color: color-mix(in srgb, var(--pcolor) 60%, #94a3b8);
      background: color-mix(in srgb, var(--pcolor) 18%, rgba(15, 23, 42, 0.2));
      box-shadow: 0 0 18px color-mix(in srgb, var(--pcolor) 40%, transparent);
      color: #f8fafc;
      font-size: 0.8rem;
      min-height: 36px;
      pointer-events: auto;
      touch-action: manipulation;
      opacity: 1;
    }

    .claim-btn.side-left,
    .claim-btn.side-right {
      top: 12px;
      bottom: 12px;
      width: min(18vw, 120px);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      display: grid;
      place-items: center;
      padding: 6px;
    }

    .claim-btn.side-left {
      left: 8px;
      transform: rotate(180deg);
    }

    .claim-btn.side-right { right: 8px; }

    .claim-btn.corner {
      width: min(24vw, 160px);
      height: min(24vw, 160px);
      border-radius: 14px;
      padding: 4px;
      display: grid;
      place-items: center;
    }

    .claim-btn.top-left { top: 8px; left: 8px; }
    .claim-btn.top-right { top: 8px; right: 8px; }
    .claim-btn.bottom-left { bottom: 8px; left: 8px; }
    .claim-btn.bottom-right { bottom: 8px; right: 8px; }

    .score-list {
      display: grid;
      gap: 8px;
      margin-top: 12px;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      border: 1px solid #475569;
      border-left: 8px solid var(--pcolor);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.95rem;
    }

  </style>
</head>
<body>
  <main class="app">
    <section class="toolbar">
      <div class="toolbar-top">
        <button id="menuToggleBtn" class="menu-toggle" type="button" aria-expanded="false" aria-controls="toolbarExtras" aria-label="Expand menu">â˜°</button>
        <div id="playersHUD" class="players" aria-live="polite"></div>
        <div id="topStatus" class="top-status" aria-live="polite">Time: 0s</div>
      </div>
      <div id="toolbarExtras" class="toolbar-extras" hidden>
        <div class="stats">
          <span id="cardsLeft">Deck: 81</span>
        </div>
        <div class="controls">
          <button id="dealBtn" type="button">Add 3 cards</button>
          <button id="hintBtn" type="button">Hint</button>
          <button id="newBtn" type="button">New game</button>
          <button id="installBtn" type="button">Install app</button>
        </div>
        <div id="message" class="msg" aria-live="polite"></div>
      </div>
    </section>
    <section class="board-wrap" aria-label="Set game area">
      <section id="board" class="grid" aria-label="Set board"></section>
      <div id="claimLayer" class="claim-layer" aria-live="polite"></div>
      <div id="startOverlay" class="overlay">
        <div class="panel">
          <h2>Set multiplayer</h2>
          <p>Select players:</p>
          <div id="playerSelect" class="panel-grid"></div>
        </div>
      </div>
      <div id="endOverlay" class="overlay" hidden>
        <div class="panel">
          <h2 id="winnerText">Game over</h2>
          <div id="scoreList" class="score-list"></div>
          <button id="playAgainBtn" type="button" style="margin-top:12px;">Play again</button>
        </div>
      </div>
    </section>
  </main>

  <div id="installOverlay" class="install-overlay" hidden>
    <div class="install-modal" role="dialog" aria-modal="true" aria-labelledby="installHelpTitle">
      <div class="install-header">
        <h3 id="installHelpTitle">Install this app</h3>
        <button id="installCloseBtn" type="button" aria-label="Close install help">âœ•</button>
      </div>
      <div class="platform-tabs" role="group" aria-label="Installation platform">
        <button id="platformIosBtn" class="platform-tab" type="button" data-platform="ios" aria-pressed="true">iOS</button>
        <button id="platformAndroidBtn" class="platform-tab" type="button" data-platform="android" aria-pressed="false">Android</button>
        <button id="platformDesktopBtn" class="platform-tab" type="button" data-platform="desktop" aria-pressed="false">Desktop</button>
      </div>
      <p id="installHelpText" class="install-help"></p>
      <div class="install-actions">
        <button id="nativeInstallBtn" type="button" hidden>Install now</button>
        <button id="installDoneBtn" type="button">Done</button>
      </div>
    </div>
  </div>

  <script>
    const COLORS = ['#e11d48', '#16a34a', '#7c3aed'];
    const SHAPES = ['oval', 'diamond', 'squiggle'];
    const FILLS = ['solid', 'striped', 'open'];

    let deck = [];
    let board = [];
    let selected = [];
    let setsFound = 0;
    let startedAt = 0;
    let timer = null;
    let playerCount = 1;
    let scores = [0];
    let awaitingClaim = false;
    let gameActive = false;
    let pendingGameOver = false;
    let deferredInstallPrompt = null;

    const BEST_TIME_STORAGE_KEY = 'set-single-player-best-time-seconds';
    let bestSinglePlayerTime = loadBestTime();

    const PLAYER_COLORS = ['#f97316', '#3b82f6', '#22c55e', '#e879f9'];
    const PLAYER_ZONES = {
      2: ['side-left', 'side-right'],
      3: ['top-left', 'top-right', 'bottom-right'],
      4: ['top-left', 'top-right', 'bottom-left', 'bottom-right']
    };

    const boardEl = document.getElementById('board');
    const claimLayerEl = document.getElementById('claimLayer');
    const playersHUDEl = document.getElementById('playersHUD');
    const msgEl = document.getElementById('message');
    const cardsLeftEl = document.getElementById('cardsLeft');
    const startOverlayEl = document.getElementById('startOverlay');
    const endOverlayEl = document.getElementById('endOverlay');
    const scoreListEl = document.getElementById('scoreList');
    const winnerTextEl = document.getElementById('winnerText');
    const playerSelectEl = document.getElementById('playerSelect');
    const installBtnEl = document.getElementById('installBtn');
    const menuToggleBtnEl = document.getElementById('menuToggleBtn');
    const toolbarExtrasEl = document.getElementById('toolbarExtras');
    const topStatusEl = document.getElementById('topStatus');
    const installOverlayEl = document.getElementById('installOverlay');
    const installHelpTextEl = document.getElementById('installHelpText');
    const nativeInstallBtnEl = document.getElementById('nativeInstallBtn');
    const platformTabEls = Array.from(document.querySelectorAll('.platform-tab'));

    const INSTALL_HELP = {
      ios: '1. Open this page in Safari.\n2. Tap the Share button (square with an up arrow).\n3. Tap â€œAdd to Home Screenâ€, then tap â€œAddâ€.',
      android: '1. Open this page in Chrome.\n2. Tap the three-dot menu.\n3. Tap â€œInstall appâ€ or â€œAdd to Home screenâ€, then confirm.',
      desktop: '1. Open this page in Chrome, Edge, or another supported browser.\n2. Click the install icon in the address bar (or open the browser menu).\n3. Choose â€œInstallâ€ to add the app.'
    };

    let toolbarCollapsed = true;

    function setToolbarCollapsed(collapsed) {
      toolbarCollapsed = collapsed;
      toolbarExtrasEl.hidden = collapsed;
      menuToggleBtnEl.setAttribute('aria-expanded', String(!collapsed));
      menuToggleBtnEl.setAttribute('aria-label', collapsed ? 'Expand menu' : 'Collapse menu');
      menuToggleBtnEl.textContent = collapsed ? 'â˜°' : 'âœ•';
    }

    function loadBestTime() {
      try {
        const stored = localStorage.getItem(BEST_TIME_STORAGE_KEY);
        if (!stored) return null;
        const parsed = Number.parseInt(stored, 10);
        return Number.isFinite(parsed) && parsed >= 0 ? parsed : null;
      } catch (_error) {
        return null;
      }
    }

    function saveBestTime(seconds) {
      try {
        localStorage.setItem(BEST_TIME_STORAGE_KEY, String(seconds));
      } catch (_error) {
        // Ignore storage failures.
      }
    }

    function updateTimeDisplays(seconds) {
      const label = `Time: ${seconds}s`;
      topStatusEl.textContent = label;
    }

    function setInstallPlatform(platform) {
      platformTabEls.forEach((btn) => {
        btn.setAttribute('aria-pressed', String(btn.dataset.platform === platform));
      });
      installHelpTextEl.textContent = INSTALL_HELP[platform] || INSTALL_HELP.desktop;
    }

    function updateNativeInstallButtonVisibility() {
      nativeInstallBtnEl.hidden = !deferredInstallPrompt;
    }

    function openInstallOverlay() {
      updateNativeInstallButtonVisibility();
      setInstallPlatform('ios');
      installOverlayEl.hidden = false;
    }

    function closeInstallOverlay() {
      installOverlayEl.hidden = true;
    }

    function updateTopStatusVisibility() {
      topStatusEl.hidden = playerCount !== 1;
    }

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          await navigator.serviceWorker.register('/vibes/set/sw.js');
        } catch (err) {
          console.error('Service worker registration failed', err);
        }
      });
    }

    window.addEventListener('beforeinstallprompt', (event) => {
      event.preventDefault();
      deferredInstallPrompt = event;
      installBtnEl.textContent = 'Install app';
      updateNativeInstallButtonVisibility();
    });

    window.addEventListener('appinstalled', () => {
      deferredInstallPrompt = null;
      installBtnEl.hidden = true;
      closeInstallOverlay();
      showMessage('App installed. You can now play offline.');
    });

    function buildDeck() {
      const cards = [];
      for (let number = 0; number < 3; number++) {
        for (let color = 0; color < 3; color++) {
          for (let shape = 0; shape < 3; shape++) {
            for (let fill = 0; fill < 3; fill++) {
              cards.push({ number, color, shape, fill, id: `${number}${color}${shape}${fill}` });
            }
          }
        }
      }
      return shuffle(cards);
    }

    function shuffle(arr) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function deal(n) {
      for (let i = 0; i < n && deck.length > 0; i++) {
        board.push(deck.pop());
      }
    }

    function isSet(a, b, c) {
      const keys = ['number', 'color', 'shape', 'fill'];
      return keys.every((k) => {
        const vals = new Set([a[k], b[k], c[k]]);
        return vals.size === 1 || vals.size === 3;
      });
    }

    function findAnySet() {
      for (let i = 0; i < board.length; i++) {
        for (let j = i + 1; j < board.length; j++) {
          for (let k = j + 1; k < board.length; k++) {
            if (isSet(board[i], board[j], board[k])) return [i, j, k];
          }
        }
      }
      return null;
    }

    function shapeMarkup(shape, fill, color) {
      const stripe = `<pattern id="p-${color.slice(1)}" width="6" height="6" patternUnits="userSpaceOnUse" patternTransform="rotate(30)"><line x1="0" y1="0" x2="0" y2="6" stroke="${color}" stroke-width="2" /></pattern>`;
      const fillValue = fill === 'solid' ? color : fill === 'open' ? 'transparent' : `url(#p-${color.slice(1)})`;
      let d = '';
      if (shape === 'oval') d = 'M12 20 Q12 8 24 8 H76 Q88 8 88 20 Q88 32 76 32 H24 Q12 32 12 20Z';
      if (shape === 'diamond') d = 'M50 7 L88 20 L50 33 L12 20 Z';
      if (shape === 'squiggle') d = 'M50 4 L61 14 L74 14 L64 22 L68 35 L50 27 L32 35 L36 22 L26 14 L39 14 Z';
      return `<svg viewBox="0 0 100 40" aria-hidden="true"><defs>${stripe}</defs><path d="${d}" fill="${fillValue}" stroke="${color}" stroke-width="3" /></svg>`;
    }

    function cardMarkup(card) {
      const count = card.number + 1;
      const color = COLORS[card.color];
      const shape = SHAPES[card.shape];
      const fill = FILLS[card.fill];
      const symbols = new Array(count).fill(0).map(() => shapeMarkup(shape, fill, color)).join('');
      return `<div class="symbols">${symbols}</div>`;
    }

    function showMessage(text) {
      msgEl.textContent = text;
    }

    function refreshHUD() {
      cardsLeftEl.textContent = `Deck: ${deck.length}`;
      playersHUDEl.innerHTML = '';
      scores.forEach((score, idx) => {
        const chip = document.createElement('span');
        chip.className = 'player-chip';
        chip.style.setProperty('--pcolor', PLAYER_COLORS[idx]);
        chip.textContent = `P${idx + 1}: ${score}`;
        if (score === Math.max(...scores)) chip.classList.add('leading');
        playersHUDEl.appendChild(chip);
      });
    }

    function renderClaimTargets() {
      claimLayerEl.innerHTML = '';
      if (playerCount === 1) return;
      const zones = PLAYER_ZONES[playerCount] || [];
      zones.forEach((zoneClass, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `claim-btn ${zoneClass} ${playerCount === 2 ? '' : 'corner'}`.trim();
        btn.style.setProperty('--pcolor', PLAYER_COLORS[idx]);
        btn.textContent = `P${idx + 1}`;
        btn.addEventListener('click', () => awardPoint(idx));
        claimLayerEl.appendChild(btn);
      });
      claimLayerEl.classList.toggle('active', awaitingClaim);
    }

    function render() {
      boardEl.innerHTML = '';
      board.forEach((card, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'card';
        btn.setAttribute('aria-label', `Card ${idx + 1}`);
        btn.innerHTML = cardMarkup(card);
        if (selected.includes(idx)) btn.classList.add('selected');
        btn.addEventListener('click', () => pickCard(idx));
        btn.disabled = awaitingClaim || !gameActive;
        boardEl.appendChild(btn);
      });
      renderClaimTargets();
      refreshHUD();
      requestAnimationFrame(updateBoardLayout);
    }

    function updateBoardLayout() {
      const cardCount = Math.max(board.length, 1);
      const rect = boardEl.getBoundingClientRect();
      const gridGap = 8;
      const maxCols = Math.min(7, cardCount);
      const ratios = [
        { name: 'landscape', value: 5 / 3 },
        { name: 'portrait', value: 3 / 5 }
      ];
      let best = null;

      for (let cols = 3; cols <= maxCols; cols++) {
        const rows = Math.ceil(cardCount / cols);
        const slotWidth = (rect.width - gridGap * (cols - 1)) / cols;
        const slotHeight = (rect.height - gridGap * (rows - 1)) / rows;
        if (slotWidth <= 0 || slotHeight <= 0) continue;

        for (const ratio of ratios) {
          const fittedWidth = Math.min(slotWidth, slotHeight * ratio.value);
          const fittedHeight = fittedWidth / ratio.value;
          const area = fittedWidth * fittedHeight;
          if (!best || area > best.area) {
            best = { cols, fittedWidth, fittedHeight, area, ratio: ratio.name };
          }
        }
      }

      if (!best) return;

      boardEl.style.setProperty('--cols', best.cols);
      boardEl.style.setProperty('--card-w', `${Math.floor(best.fittedWidth)}px`);
      boardEl.style.setProperty('--card-h', `${Math.floor(best.fittedHeight)}px`);
      const symbolMax = Math.max(36, Math.floor(Math.min(best.fittedWidth, best.fittedHeight) * 0.72));
      boardEl.style.setProperty('--symbol-max', `${symbolMax}px`);
      boardEl.classList.toggle('portrait-cards', best.ratio === 'portrait');
      boardEl.classList.toggle('landscape-cards', best.ratio === 'landscape');
    }

    function clearPickStyles(cls) {
      selected.forEach((i) => {
        const el = boardEl.children[i];
        if (el) {
          el.classList.remove('selected');
          el.classList.add(cls);
        }
      });
      setTimeout(() => render(), 360);
    }

    function pickCard(idx) {
      if (awaitingClaim || !gameActive) return;
      const pos = selected.indexOf(idx);
      if (pos >= 0) {
        selected.splice(pos, 1);
        render();
        return;
      }
      if (selected.length === 3) return;
      selected.push(idx);
      render();
      if (selected.length !== 3) return;
      const [a, b, c] = selected.map((i) => board[i]);
      if (isSet(a, b, c)) {
        if (playerCount === 1) {
          scores[0] += 1;
        } else {
          awaitingClaim = true;
        }
        clearPickStyles('good');
        const toRemove = [...selected].sort((x, y) => y - x);
        toRemove.forEach((i) => board.splice(i, 1));
        setsFound += 1;
        selected = [];
        if (board.length < 12) deal(12 - board.length);
        while (board.length && !findAnySet() && deck.length > 0) {
          deal(3);
        }
        if (!findAnySet() && deck.length === 0) {
          if (playerCount === 1) {
            finishGame();
          } else {
            pendingGameOver = true;
            showMessage('Final set found â€” claim the last point.');
          }
        } else {
          showMessage(playerCount === 1 ? 'Nice set!' : 'Set found â€” tap your side/corner to claim point.');
        }
        render();
      } else {
        showMessage('Not a set.');
        clearPickStyles('bad');
        selected = [];
      }
    }

    function awardPoint(playerIdx) {
      if (!awaitingClaim || !gameActive) return;
      scores[playerIdx] += 1;
      awaitingClaim = false;
      showMessage(`Player ${playerIdx + 1} scores!`);
      if (pendingGameOver) {
        finishGame();
        return;
      }
      render();
    }

    function addCards() {
      if (!gameActive || awaitingClaim) return;
      if (deck.length === 0) {
        showMessage('Deck is empty.');
        return;
      }
      deal(3);
      render();
    }

    function hint() {
      if (!gameActive || awaitingClaim) return;
      const found = findAnySet();
      if (!found) {
        showMessage('No sets on board. Add cards.');
        return;
      }
      selected = [found[0]];
      render();
      showMessage('Hint: one card is highlighted.');
    }

    function resetGame() {
      deck = buildDeck();
      board = [];
      selected = [];
      setsFound = 0;
      scores = new Array(playerCount).fill(0);
      awaitingClaim = false;
      gameActive = true;
      pendingGameOver = false;
      endOverlayEl.hidden = true;
      startedAt = Date.now();
      updateTopStatusVisibility();
      updateTimeDisplays(0);
      deal(12);
      while (!findAnySet() && deck.length > 0) {
        deal(3);
      }
      showMessage('Find a set: all same or all different for each trait.');
      render();
      if (timer) clearInterval(timer);
      timer = setInterval(() => {
        const sec = Math.floor((Date.now() - startedAt) / 1000);
        updateTimeDisplays(sec);
      }, 1000);
    }

    function finishGame() {
      gameActive = false;
      awaitingClaim = false;
      pendingGameOver = false;
      const elapsedSeconds = Math.floor((Date.now() - startedAt) / 1000);
      updateTimeDisplays(elapsedSeconds);
      const best = Math.max(...scores);
      const winners = scores.map((v, i) => ({ v, i })).filter((x) => x.v === best);
      if (playerCount === 1) {
        winnerTextEl.textContent = `Finished in ${elapsedSeconds}s`;
      } else {
        winnerTextEl.textContent = winners.length === 1 ? `Winner: Player ${winners[0].i + 1}` : `Tie: ${winners.map((w) => `Player ${w.i + 1}`).join(', ')}`;
      }
      scoreListEl.innerHTML = '';
      if (playerCount === 1) {
        const currentRow = document.createElement('div');
        currentRow.className = 'score-row';
        currentRow.style.setProperty('--pcolor', '#60a5fa');
        currentRow.innerHTML = `<span>Your time</span><strong>${elapsedSeconds}s</strong>`;
        scoreListEl.appendChild(currentRow);

        const previousBest = bestSinglePlayerTime;
        if (bestSinglePlayerTime === null || elapsedSeconds < bestSinglePlayerTime) {
          bestSinglePlayerTime = elapsedSeconds;
          saveBestTime(bestSinglePlayerTime);
        }

        const bestRow = document.createElement('div');
        bestRow.className = 'score-row';
        bestRow.style.setProperty('--pcolor', '#34d399');
        const suffix = previousBest === null || elapsedSeconds < previousBest ? ' ðŸŽ‰ New best!' : '';
        bestRow.innerHTML = `<span>Best time</span><strong>${bestSinglePlayerTime}s${suffix}</strong>`;
        scoreListEl.appendChild(bestRow);
      } else {
        scores.forEach((score, idx) => {
          const row = document.createElement('div');
          row.className = 'score-row';
          row.style.setProperty('--pcolor', PLAYER_COLORS[idx]);
          row.innerHTML = `<span>Player ${idx + 1}</span><strong>${score}</strong>`;
          scoreListEl.appendChild(row);
        });
      }
      endOverlayEl.hidden = false;
      showMessage('Game over â€” no sets left.');
      if (timer) clearInterval(timer);
      render();
    }

    function buildStartScreen() {
      playerSelectEl.innerHTML = '';
      [1, 2, 3, 4].forEach((count) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = `${count} player${count > 1 ? 's' : ''}`;
        btn.addEventListener('click', () => {
          playerCount = count;
          startOverlayEl.hidden = true;
          resetGame();
        });
        playerSelectEl.appendChild(btn);
      });
    }

    document.getElementById('dealBtn').addEventListener('click', addCards);
    document.getElementById('hintBtn').addEventListener('click', hint);
    document.getElementById('newBtn').addEventListener('click', () => {
      startOverlayEl.hidden = false;
      endOverlayEl.hidden = true;
      gameActive = false;
      awaitingClaim = false;
      pendingGameOver = false;
      if (timer) clearInterval(timer);
      updateTimeDisplays(0);
      showMessage('Select player count to begin.');
      render();
    });
    document.getElementById('playAgainBtn').addEventListener('click', resetGame);
    menuToggleBtnEl.addEventListener('click', () => {
      setToolbarCollapsed(!toolbarCollapsed);
    });
    installBtnEl.addEventListener('click', async () => {
      openInstallOverlay();
    });
    document.getElementById('installCloseBtn').addEventListener('click', closeInstallOverlay);
    document.getElementById('installDoneBtn').addEventListener('click', closeInstallOverlay);
    installOverlayEl.addEventListener('click', (event) => {
      if (event.target === installOverlayEl) closeInstallOverlay();
    });
    platformTabEls.forEach((btn) => {
      btn.addEventListener('click', () => {
        setInstallPlatform(btn.dataset.platform);
      });
    });
    nativeInstallBtnEl.addEventListener('click', async () => {
      if (!deferredInstallPrompt) {
        showMessage('Install prompt not available right now. Use the browser menu steps above.');
        return;
      }
      deferredInstallPrompt.prompt();
      const choice = await deferredInstallPrompt.userChoice;
      deferredInstallPrompt = null;
      updateNativeInstallButtonVisibility();
      if (choice.outcome === 'accepted') {
        showMessage('Installing app...');
        closeInstallOverlay();
      } else {
        showMessage('Install canceled. You can try again any time.');
      }
    });
    window.addEventListener('resize', updateBoardLayout);

    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      installBtnEl.hidden = true;
    } else {
      installBtnEl.hidden = false;
      installBtnEl.textContent = 'Install app';
    }
    updateNativeInstallButtonVisibility();

    buildStartScreen();
    setToolbarCollapsed(true);
    updateTopStatusVisibility();
    updateTimeDisplays(0);
    showMessage('Select player count to begin.');
    render();
  </script>
</body>
</html>
