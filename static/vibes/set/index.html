<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="/vibes/set/manifest.webmanifest" />
  <link rel="icon" href="/favicon.ico" sizes="any" />
  <link rel="icon" href="/favicon-96x96.png" type="image/png" />
  <title>Set</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #111827;
      --panel: #1f2937;
      --card: #f8fafc;
      --ink: #0f172a;
      --ok: #10b981;
      --bad: #ef4444;
      --muted: #94a3b8;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(180deg, #0f172a, var(--bg));
      color: #e2e8f0;
      min-height: 100svh;
    }

    .app {
      width: min(100%, 1000px);
      margin: 0 auto;
      padding: 12px;
      display: grid;
      grid-template-rows: auto minmax(0, 1fr);
      gap: 12px;
      height: 100svh;
      overflow: hidden;
    }

    .toolbar {
      background: rgba(31, 41, 55, 0.9);
      border: 1px solid #334155;
      border-radius: 14px;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .stats {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .players {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    .player-chip {
      border: 1px solid color-mix(in srgb, var(--pcolor) 60%, #334155);
      color: #e2e8f0;
      border-radius: 999px;
      padding: 4px 8px;
      background: color-mix(in srgb, var(--pcolor) 22%, #0f172a);
      opacity: 0.75;
    }

    .player-chip.leading {
      opacity: 1;
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--pcolor) 50%, transparent) inset;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    #installBtn {
      border-color: #60a5fa;
      background: color-mix(in srgb, #2563eb 32%, #0f172a);
      color: #eff6ff;
    }

    @media (max-width: 520px) {
      .controls {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    button {
      appearance: none;
      border: 1px solid #475569;
      background: #0f172a;
      color: #e2e8f0;
      border-radius: 10px;
      padding: 10px;
      font-size: 0.95rem;
      font-weight: 650;
      min-height: 44px;
    }

    button:active { transform: translateY(1px); }

    .grid {
      display: grid;
      --grid-gap: 8px;
      --cols: 3;
      --card-w: 120px;
      --card-h: 200px;
      gap: var(--grid-gap);
      grid-template-columns: repeat(var(--cols), minmax(0, var(--card-w)));
      grid-auto-rows: var(--card-h);
      min-height: 0;
      align-content: center;
      justify-content: center;
      overflow: hidden;
    }

    .board-wrap {
      position: relative;
      min-height: 0;
      display: grid;
      overflow: hidden;
      border-radius: 14px;
    }

    .card {
      border: 3px solid transparent;
      background: var(--card);
      color: var(--ink);
      border-radius: 12px;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      touch-action: manipulation;
      overflow: hidden;
    }

    .card.selected { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.25) inset; }
    .card.good { border-color: var(--ok); }
    .card.bad { border-color: var(--bad); }

    .symbols {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-evenly;
      gap: 4px;
      flex-wrap: nowrap;
      flex-direction: column;
    }

    .symbols svg {
      width: min(100%, var(--symbol-max, 100px));
      height: auto;
      flex: 0 1 auto;
    }

    .grid.portrait-cards .symbols {
      gap: 2px;
    }

    .grid.landscape-cards .symbols {
      transform: rotate(90deg);
      transform-origin: center;
    }

    .msg {
      min-height: 1.2em;
      font-size: 0.95rem;
      color: var(--muted);
    }


    [hidden] { display: none !important; }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #334155;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 5;
    }

    .panel {
      background: rgba(31, 41, 55, 0.95);
      border: 1px solid #475569;
      border-radius: 16px;
      padding: 16px;
      width: min(100%, 500px);
      text-align: center;
    }

    .panel h2 { margin: 0 0 10px; }

    .panel-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .claim-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 4;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .claim-layer.active {
      pointer-events: auto;
      background: rgba(15, 23, 42, 0.25);
      opacity: 1;
      visibility: visible;
    }

    .claim-btn {
      position: absolute;
      border-width: 3px;
      border-color: color-mix(in srgb, var(--pcolor) 60%, #94a3b8);
      background: color-mix(in srgb, var(--pcolor) 18%, rgba(15, 23, 42, 0.2));
      box-shadow: 0 0 18px color-mix(in srgb, var(--pcolor) 40%, transparent);
      color: #f8fafc;
      font-size: 0.8rem;
      min-height: 36px;
      pointer-events: auto;
      touch-action: manipulation;
      opacity: 1;
    }

    .claim-btn.side-left,
    .claim-btn.side-right {
      top: 12px;
      bottom: 12px;
      width: min(18vw, 120px);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      display: grid;
      place-items: center;
      padding: 6px;
    }

    .claim-btn.side-left {
      left: 8px;
      transform: rotate(180deg);
    }

    .claim-btn.side-right { right: 8px; }

    .claim-btn.corner {
      width: min(24vw, 160px);
      height: min(24vw, 160px);
      border-radius: 14px;
      padding: 4px;
      display: grid;
      place-items: center;
    }

    .claim-btn.top-left { top: 8px; left: 8px; }
    .claim-btn.top-right { top: 8px; right: 8px; }
    .claim-btn.bottom-left { bottom: 8px; left: 8px; }
    .claim-btn.bottom-right { bottom: 8px; right: 8px; }

    .score-list {
      display: grid;
      gap: 8px;
      margin-top: 12px;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      border: 1px solid #475569;
      border-left: 8px solid var(--pcolor);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.95rem;
    }

  </style>
</head>
<body>
  <main class="app">
    <section class="toolbar">
      <div class="stats">
        <span id="cardsLeft">Deck: 81</span>
        <span id="time">Time: 0s</span>
      </div>
      <div id="playersHUD" class="players" aria-live="polite"></div>
      <div class="controls">
        <button id="dealBtn" type="button">Add 3 cards</button>
        <button id="hintBtn" type="button">Hint</button>
        <button id="newBtn" type="button">New game</button>
        <button id="installBtn" type="button">Install app</button>
      </div>
      <div id="message" class="msg" aria-live="polite"></div>
    </section>
    <section class="board-wrap" aria-label="Set game area">
      <section id="board" class="grid" aria-label="Set board"></section>
      <div id="claimLayer" class="claim-layer" aria-live="polite"></div>
      <div id="startOverlay" class="overlay">
        <div class="panel">
          <h2>Set multiplayer</h2>
          <p>Select players:</p>
          <div id="playerSelect" class="panel-grid"></div>
        </div>
      </div>
      <div id="endOverlay" class="overlay" hidden>
        <div class="panel">
          <h2 id="winnerText">Game over</h2>
          <div id="scoreList" class="score-list"></div>
          <button id="playAgainBtn" type="button" style="margin-top:12px;">Play again</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    const COLORS = ['#e11d48', '#16a34a', '#7c3aed'];
    const SHAPES = ['oval', 'diamond', 'squiggle'];
    const FILLS = ['solid', 'striped', 'open'];

    let deck = [];
    let board = [];
    let selected = [];
    let setsFound = 0;
    let startedAt = 0;
    let timer = null;
    let playerCount = 1;
    let scores = [0];
    let awaitingClaim = false;
    let gameActive = false;
    let pendingGameOver = false;
    let deferredInstallPrompt = null;

    const PLAYER_COLORS = ['#f97316', '#3b82f6', '#22c55e', '#e879f9'];
    const PLAYER_ZONES = {
      2: ['side-left', 'side-right'],
      3: ['top-left', 'top-right', 'bottom-right'],
      4: ['top-left', 'top-right', 'bottom-left', 'bottom-right']
    };

    const boardEl = document.getElementById('board');
    const claimLayerEl = document.getElementById('claimLayer');
    const playersHUDEl = document.getElementById('playersHUD');
    const msgEl = document.getElementById('message');
    const cardsLeftEl = document.getElementById('cardsLeft');
    const timeEl = document.getElementById('time');
    const startOverlayEl = document.getElementById('startOverlay');
    const endOverlayEl = document.getElementById('endOverlay');
    const scoreListEl = document.getElementById('scoreList');
    const winnerTextEl = document.getElementById('winnerText');
    const playerSelectEl = document.getElementById('playerSelect');
    const installBtnEl = document.getElementById('installBtn');

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          await navigator.serviceWorker.register('/vibes/set/sw.js');
        } catch (err) {
          console.error('Service worker registration failed', err);
        }
      });
    }

    window.addEventListener('beforeinstallprompt', (event) => {
      event.preventDefault();
      deferredInstallPrompt = event;
      installBtnEl.textContent = 'Install app';
    });

    window.addEventListener('appinstalled', () => {
      deferredInstallPrompt = null;
      installBtnEl.hidden = true;
      showMessage('App installed. You can now play offline.');
    });

    function buildDeck() {
      const cards = [];
      for (let number = 0; number < 3; number++) {
        for (let color = 0; color < 3; color++) {
          for (let shape = 0; shape < 3; shape++) {
            for (let fill = 0; fill < 3; fill++) {
              cards.push({ number, color, shape, fill, id: `${number}${color}${shape}${fill}` });
            }
          }
        }
      }
      return shuffle(cards);
    }

    function shuffle(arr) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function deal(n) {
      for (let i = 0; i < n && deck.length > 0; i++) {
        board.push(deck.pop());
      }
    }

    function isSet(a, b, c) {
      const keys = ['number', 'color', 'shape', 'fill'];
      return keys.every((k) => {
        const vals = new Set([a[k], b[k], c[k]]);
        return vals.size === 1 || vals.size === 3;
      });
    }

    function findAnySet() {
      for (let i = 0; i < board.length; i++) {
        for (let j = i + 1; j < board.length; j++) {
          for (let k = j + 1; k < board.length; k++) {
            if (isSet(board[i], board[j], board[k])) return [i, j, k];
          }
        }
      }
      return null;
    }

    function shapeMarkup(shape, fill, color) {
      const stripe = `<pattern id="p-${color.slice(1)}" width="6" height="6" patternUnits="userSpaceOnUse" patternTransform="rotate(30)"><line x1="0" y1="0" x2="0" y2="6" stroke="${color}" stroke-width="2" /></pattern>`;
      const fillValue = fill === 'solid' ? color : fill === 'open' ? 'transparent' : `url(#p-${color.slice(1)})`;
      let d = '';
      if (shape === 'oval') d = 'M12 20 Q12 8 24 8 H76 Q88 8 88 20 Q88 32 76 32 H24 Q12 32 12 20Z';
      if (shape === 'diamond') d = 'M50 7 L88 20 L50 33 L12 20 Z';
      if (shape === 'squiggle') d = 'M50 4 L61 14 L74 14 L64 22 L68 35 L50 27 L32 35 L36 22 L26 14 L39 14 Z';
      return `<svg viewBox="0 0 100 40" aria-hidden="true"><defs>${stripe}</defs><path d="${d}" fill="${fillValue}" stroke="${color}" stroke-width="3" /></svg>`;
    }

    function cardMarkup(card) {
      const count = card.number + 1;
      const color = COLORS[card.color];
      const shape = SHAPES[card.shape];
      const fill = FILLS[card.fill];
      const symbols = new Array(count).fill(0).map(() => shapeMarkup(shape, fill, color)).join('');
      return `<div class="symbols">${symbols}</div>`;
    }

    function showMessage(text) {
      msgEl.textContent = text;
    }

    function refreshHUD() {
      cardsLeftEl.textContent = `Deck: ${deck.length}`;
      playersHUDEl.innerHTML = '';
      scores.forEach((score, idx) => {
        const chip = document.createElement('span');
        chip.className = 'player-chip';
        chip.style.setProperty('--pcolor', PLAYER_COLORS[idx]);
        chip.textContent = `P${idx + 1}: ${score}`;
        if (score === Math.max(...scores)) chip.classList.add('leading');
        playersHUDEl.appendChild(chip);
      });
    }

    function renderClaimTargets() {
      claimLayerEl.innerHTML = '';
      if (playerCount === 1) return;
      const zones = PLAYER_ZONES[playerCount] || [];
      zones.forEach((zoneClass, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `claim-btn ${zoneClass} ${playerCount === 2 ? '' : 'corner'}`.trim();
        btn.style.setProperty('--pcolor', PLAYER_COLORS[idx]);
        btn.textContent = `P${idx + 1}`;
        btn.addEventListener('click', () => awardPoint(idx));
        claimLayerEl.appendChild(btn);
      });
      claimLayerEl.classList.toggle('active', awaitingClaim);
    }

    function render() {
      boardEl.innerHTML = '';
      board.forEach((card, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'card';
        btn.setAttribute('aria-label', `Card ${idx + 1}`);
        btn.innerHTML = cardMarkup(card);
        if (selected.includes(idx)) btn.classList.add('selected');
        btn.addEventListener('click', () => pickCard(idx));
        btn.disabled = awaitingClaim || !gameActive;
        boardEl.appendChild(btn);
      });
      renderClaimTargets();
      refreshHUD();
      requestAnimationFrame(updateBoardLayout);
    }

    function updateBoardLayout() {
      const cardCount = Math.max(board.length, 1);
      const rect = boardEl.getBoundingClientRect();
      const gridGap = 8;
      const maxCols = Math.min(7, cardCount);
      const ratios = [
        { name: 'landscape', value: 5 / 3 },
        { name: 'portrait', value: 3 / 5 }
      ];
      let best = null;

      for (let cols = 3; cols <= maxCols; cols++) {
        const rows = Math.ceil(cardCount / cols);
        const slotWidth = (rect.width - gridGap * (cols - 1)) / cols;
        const slotHeight = (rect.height - gridGap * (rows - 1)) / rows;
        if (slotWidth <= 0 || slotHeight <= 0) continue;

        for (const ratio of ratios) {
          const fittedWidth = Math.min(slotWidth, slotHeight * ratio.value);
          const fittedHeight = fittedWidth / ratio.value;
          const area = fittedWidth * fittedHeight;
          if (!best || area > best.area) {
            best = { cols, fittedWidth, fittedHeight, area, ratio: ratio.name };
          }
        }
      }

      if (!best) return;

      boardEl.style.setProperty('--cols', best.cols);
      boardEl.style.setProperty('--card-w', `${Math.floor(best.fittedWidth)}px`);
      boardEl.style.setProperty('--card-h', `${Math.floor(best.fittedHeight)}px`);
      const symbolMax = Math.max(36, Math.floor(Math.min(best.fittedWidth, best.fittedHeight) * 0.72));
      boardEl.style.setProperty('--symbol-max', `${symbolMax}px`);
      boardEl.classList.toggle('portrait-cards', best.ratio === 'portrait');
      boardEl.classList.toggle('landscape-cards', best.ratio === 'landscape');
    }

    function clearPickStyles(cls) {
      selected.forEach((i) => {
        const el = boardEl.children[i];
        if (el) {
          el.classList.remove('selected');
          el.classList.add(cls);
        }
      });
      setTimeout(() => render(), 360);
    }

    function pickCard(idx) {
      if (awaitingClaim || !gameActive) return;
      const pos = selected.indexOf(idx);
      if (pos >= 0) {
        selected.splice(pos, 1);
        render();
        return;
      }
      if (selected.length === 3) return;
      selected.push(idx);
      render();
      if (selected.length !== 3) return;
      const [a, b, c] = selected.map((i) => board[i]);
      if (isSet(a, b, c)) {
        if (playerCount === 1) {
          scores[0] += 1;
        } else {
          awaitingClaim = true;
        }
        clearPickStyles('good');
        const toRemove = [...selected].sort((x, y) => y - x);
        toRemove.forEach((i) => board.splice(i, 1));
        setsFound += 1;
        selected = [];
        if (board.length < 12) deal(12 - board.length);
        while (board.length && !findAnySet() && deck.length > 0) {
          deal(3);
        }
        if (!findAnySet() && deck.length === 0) {
          if (playerCount === 1) {
            finishGame();
          } else {
            pendingGameOver = true;
            showMessage('Final set found — claim the last point.');
          }
        } else {
          showMessage(playerCount === 1 ? 'Nice set!' : 'Set found — tap your side/corner to claim point.');
        }
        render();
      } else {
        showMessage('Not a set.');
        clearPickStyles('bad');
        selected = [];
      }
    }

    function awardPoint(playerIdx) {
      if (!awaitingClaim || !gameActive) return;
      scores[playerIdx] += 1;
      awaitingClaim = false;
      showMessage(`Player ${playerIdx + 1} scores!`);
      if (pendingGameOver) {
        finishGame();
        return;
      }
      render();
    }

    function addCards() {
      if (!gameActive || awaitingClaim) return;
      if (deck.length === 0) {
        showMessage('Deck is empty.');
        return;
      }
      deal(3);
      render();
    }

    function hint() {
      if (!gameActive || awaitingClaim) return;
      const found = findAnySet();
      if (!found) {
        showMessage('No sets on board. Add cards.');
        return;
      }
      selected = [found[0]];
      render();
      showMessage('Hint: one card is highlighted.');
    }

    function resetGame() {
      deck = buildDeck();
      board = [];
      selected = [];
      setsFound = 0;
      scores = new Array(playerCount).fill(0);
      awaitingClaim = false;
      gameActive = true;
      pendingGameOver = false;
      endOverlayEl.hidden = true;
      startedAt = Date.now();
      deal(12);
      while (!findAnySet() && deck.length > 0) {
        deal(3);
      }
      showMessage('Find a set: all same or all different for each trait.');
      render();
      if (timer) clearInterval(timer);
      timer = setInterval(() => {
        const sec = Math.floor((Date.now() - startedAt) / 1000);
        timeEl.textContent = `Time: ${sec}s`;
      }, 1000);
    }

    function finishGame() {
      gameActive = false;
      awaitingClaim = false;
      pendingGameOver = false;
      const best = Math.max(...scores);
      const winners = scores.map((v, i) => ({ v, i })).filter((x) => x.v === best);
      winnerTextEl.textContent = winners.length === 1 ? `Winner: Player ${winners[0].i + 1}` : `Tie: ${winners.map((w) => `Player ${w.i + 1}`).join(', ')}`;
      scoreListEl.innerHTML = '';
      scores.forEach((score, idx) => {
        const row = document.createElement('div');
        row.className = 'score-row';
        row.style.setProperty('--pcolor', PLAYER_COLORS[idx]);
        row.innerHTML = `<span>Player ${idx + 1}</span><strong>${score}</strong>`;
        scoreListEl.appendChild(row);
      });
      endOverlayEl.hidden = false;
      showMessage('Game over — no sets left.');
      if (timer) clearInterval(timer);
      render();
    }

    function buildStartScreen() {
      playerSelectEl.innerHTML = '';
      [1, 2, 3, 4].forEach((count) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = `${count} player${count > 1 ? 's' : ''}`;
        btn.addEventListener('click', () => {
          playerCount = count;
          startOverlayEl.hidden = true;
          resetGame();
        });
        playerSelectEl.appendChild(btn);
      });
    }

    document.getElementById('dealBtn').addEventListener('click', addCards);
    document.getElementById('hintBtn').addEventListener('click', hint);
    document.getElementById('newBtn').addEventListener('click', () => {
      startOverlayEl.hidden = false;
      endOverlayEl.hidden = true;
      gameActive = false;
      awaitingClaim = false;
      pendingGameOver = false;
      if (timer) clearInterval(timer);
      showMessage('Select player count to begin.');
      render();
    });
    document.getElementById('playAgainBtn').addEventListener('click', resetGame);
    installBtnEl.addEventListener('click', async () => {
      if (!deferredInstallPrompt) {
        showMessage('Use your browser menu to install this app.');
        return;
      }
      deferredInstallPrompt.prompt();
      const choice = await deferredInstallPrompt.userChoice;
      deferredInstallPrompt = null;
      if (choice.outcome === 'accepted') {
        showMessage('Installing app...');
      } else {
        showMessage('Install canceled. You can try again any time.');
      }
    });
    window.addEventListener('resize', updateBoardLayout);

    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      installBtnEl.hidden = true;
    } else {
      installBtnEl.hidden = false;
      installBtnEl.textContent = 'Install app';
    }

    buildStartScreen();
    showMessage('Select player count to begin.');
    render();
  </script>
</body>
</html>
